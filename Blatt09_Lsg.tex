\documentclass[a4paper,10pt]{article}
\usepackage[ngerman]{babel}		%dt. Übersetzung und Umlaute
\usepackage[utf8]{inputenc}		%Umlaute direkt eingeben
\usepackage{mathtools}			%Mathekrams
\usepackage{paralist}			%bessere Listen
\usepackage{amssymb}			%Mathesymbole
\usepackage{amsthm}			%typesetting theorems (Text über = u.ä.)
\usepackage{fancyhdr} 			%Headerstyles
\usepackage{verbatim}			%Sourcecode einfügen
\usepackage[margin=2.0cm,headheight=40pt,top=3cm]{geometry}
\usepackage{tikz}
\usepackage{cancel}
\usepackage{stmaryrd}
\usepackage{colortbl}
\newcolumntype{L}[1]{>{\raggedright\arraybackslash}p{#1}} % linksbündig mit Breitenangabe
\usetikzlibrary{matrix,positioning,arrows, automata}

\pagestyle{fancy}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
\lhead{Blatt 09}
\rhead{}
\cfoot{}
\rfoot{\thepage}
\begin{document}
	\parindent0pt
	\textbf{Aufgabe 01}
	\begin{compactenum} [(a)]
		\item $ \varphi := \exists x\exists y \forall z (E(x,z) \vee E(y,z))$\\\\
		Dann gilt: \[ \mathcal{A} \models \varphi \text{und } \mathcal{B} \not\models \varphi \text{d.h.} \mathcal{B} \models \lnot \varphi \Longrightarrow \lnot \varphi \equiv \forall x \forall y \exists z (\lnot E(x,z) \wedge \lnot E(y,z)) \]
		Also gilt:\\
		\begin{tabbing}
			$ \mathcal{A} \models \exists x\exists y \forall z (E(x,z) \vee E(y,z))$ \qquad \qquad \qquad \= (R1) \\
			$ \mathcal{B} \models \forall x \forall y \exists z (\lnot E(x,z) \wedge \lnot E(y,z)) $
			\> (R2)
		\end{tabbing} \
		
		Gewinnstrategie:\\
		\begin{tabbing}
			\underline{Runde 1}: \= Spoiler wählt ein $ a_1 \in A $ so das gilt:\\
			\> $ \mathcal{A} \models \big( \exists y \forall z (E(x,z) \vee E(y,z)) \big) [a_1] $\\
			\> Dieses $ a_1 $ ist gerade einer der beiden Knoten, der vier Nachbarknoten hat.\\
			\> Duplicator wählt nun einen beliebigen Knoten $ b_1 \in B$ so dass gilt:\\
			\> $ \mathcal{B} \models \big(\forall y \exists z (\lnot E(x,z) \wedge \lnot E(y,z))\big) [b_1] $\\\\

			\underline{Runde 2}: Spoiler wählt ein $ a_2 \in A$ so das gilt:\\
			\> $\mathcal{A} \models \big(\forall z (E(x,z) \vee E(y,z))\big) [a_1][a_2]$\\
			\> Dieses $ a_2 $ ist der andere Knoten in A, der vier Nachbarknoten hat.\\
			\> Duplicator wählt nun einen beliebigen Knoten $ b_2 \in B $, der allerdings mit $ b_1 $ verbunden sein muss.\\
			\> Also gilt:\\
			\> $ \mathcal{B} \models \big(\exists z (\lnot E(x,z) \wedge \lnot E(y,z))\big) [b_1][b_2] $\\\\
			
			\underline{Runde 3}: Spoiler wählt ein Knoten $ b_3 \in B $ so dass gilt:\\
			\> $ \mathcal{B} \models \big(\lnot E(x,z) \wedge \lnot E(y,z)\big) [b_1][b_2][b_3] $\\
			\> Der Knoten $ b_3 $ ist nun nicht mit $ b_1 $ oder mit $ b_2 $ verbunden.\\
			\> Wir wissen nun wegen (R1), dass jeder Knoten $ a_3 \in A $ den Duplicator wählen kann \\
			\> entweder mit $ a_1 $ oder $ a_2 $ verbunden ist und somit gilt: \\
			\> $\mathcal{A} \models \big(E(x,z) \vee E(y,z)\big) [a_1][a_2][a_3]$\\
		\end{tabbing}\
		Am Ende der Partie wissen wir gemäß (R1) und (R2), dass folgendes gilt:\\
		\[ \big(\{(a_1,a_2),(a_2,a_3)\}\in E^\mathcal{A}\big)  \text{oder } \big(\{(a_1,a_2),(a_1,a_3)\}\in E^\mathcal{A}\big) \] 
		und\\
		\[ \big((b_1,b_2)\in E^\mathcal{B} \text{ und } \{(b_1,b_3),(b_2,b_3)\} \not\in E^\mathcal{B}\big) \text{ oder }  \big((b_1,b_2)\not\in E^\mathcal{B} \text{ und } \{(b_1,b_3),(b_2,b_3)\} \not\in E^\mathcal{B}\big) \]\\
		
		In allen Fällen hat Duplicator verloren. Somit hat Spoiler eine Gewinnstrategie in 3-Runden EF-Spiel auf $\mathcal{A}$ und $\mathcal{B}$\\
		
		\item Es existiert keine bessere Gewinnstrategie, da in m = 2 sich folgendes Szenario abspielen würde:\\
		In der ersten Runde wählen Spoiler und Duplicator beliebige Knoten aus A und B. Nun hat Spoiler in der zweiten Runde die Wahl, ob er einen benachbarten Knoten zu einem schon existieren wählt oder nicht. Ganz egal wie er sich entscheidet, könnte Duplicator ihm gleichziehen, da es in der Struktur $ \mathcal{A} $ und $ \mathcal{B} $ zu jedem Knoten einen Nachbarknoten gibt als auch einen nicht benachbarten. 
	\end{compactenum}\ \\
	
	\textbf{Aufgabe 02}\\
	TODO
	
	\newpage

	\textbf{Aufgabe 03}\\
	
	\begin{compactenum} [(a)]
		\item Aussagenlogische Formel in AL, $\sigma $-Term, atomare $ \sigma $-Formel und/oder FO[$ \sigma $]-Formel \\
		
		\begin{tabular}  {c|L{3cm}|L{3cm}|L{4cm}|L{4cm}}
			& AL-Formel &$ \sigma $- Term & atomare $ \sigma $-Formel & FO[$ \sigma $]-Formel\\ \hline
			
			(i) &true& kein $ \sigma $-Term, da das '$ \wedge $'$ \not\in A_{\sigma -Terme}$ & keine atomare $ \sigma $-Formel, da diese kein '$ \wedge $' beinhalten darf & keine FO[$ \sigma $]-Formel, da nur die Verundung zweier FO[$ \sigma $]-Formeln wieder eine FO[$ \sigma $]-Formel ergibt. Hier handelt es sich um die Verundung von zwei Aussagenvariablen \\ \hline
			
			(ii) &nicht $ \in AL $, da $ v_1,v_2 \not\in AS$& kein $ \sigma $-Term, da das '$ \wedge $'$ \not\in A_{\sigma -Terme}$  & keine atomare $ \sigma $-Formel, da diese kein '$ \wedge $' beinhalten darf & Keine FO[$ \sigma $]-Formel, da FO[$ \sigma $]-Formeln atomare $ \sigma $-Formeln oder Verknüpfungen von diesen sind, definiert durch die rekursiven Regeln. In FO[$ \sigma $]-Formeln muss also mindestens ein Relationssymbol oder ein Gleichheitszeichen vorkommen. \\ \hline
			
			(iii) &nicht $ \in AL $, da $ f \not\in A_{AL} $& true & keine atomare $ \sigma $-Formel, da dies nur ein $ \sigma$-Term ist& keine FO[$ \sigma $]-Formel, da dies nur ein $ \sigma$-Term ist \\ \hline
			
			(iv) &nicht $ \in AL $, da $ f \not\in A_{AL} $& kein $ \sigma $-Term, sondern die Belegung eines $ \sigma $-Terms unter der Belegung $ \mathcal{I} = (\mathcal{A},ß)$ & keine atomare $ \sigma $-Formel, da diese u.a. kein 'ß' beinhalten darf & keine FO[$ \sigma $]-Formel, da es die Belegung eines $ \sigma $-Terms ist \\ \hline
			
			(v) &nicht $ \in AL $, da $ f \not\in A_{AL} $& kein $ \sigma $-Term, da u.a. $ R \not\in A_{\sigma -Terme}$ &true& true, frei(formel v) = $ \{v_2,v_3\} \Longrightarrow$ kein FO[$ \sigma $]-Satz \\ \hline
			
			(vi) & nicht $ \in AL $, da $ f \not\in A_{AL} $& kein $ \sigma $-Term, da u.a. $ R \not\in A_{\sigma -Terme}$ &keine atomare $ \sigma $-Formel, da diese u.a. kein 'ß' beinhalten darf& das ist keine FO[$ \sigma $]-Formel sondern die Belegung einer FO[$ \sigma $]-Formel unter der Interpretation $ \mathcal{I} = (\mathcal{A},ß)$\\ \hline
			
			(vii) & nicht $ \in AL $, da $ f \not\in A_{AL} $& kein $ \sigma $-Term, da u.a. $ '= ' \not\in A_{\sigma -Terme}$ &keine atomare $ \sigma $-Formel, da diese u.a. kein '$ \lnot $' beinhalten darf& keine FO[$ \sigma $]-Formel, da 'f' ein 1-stelliges Funktionssymbol ist und das Argument demnach nicht $ 'v_7 \vee v_7' $ sein darf\\ \hline
			
			(viii) & nicht $ \in AL $, da $ f \not\in A_{AL} $& kein $ \sigma $-Term, da u.a. $ R \not\in A_{\sigma -Terme}$ &keine atomare $ \sigma $-Formel, da diese u.a. kein '$ \wedge $' beinhalten darf& true, frei(formel viii) = $ \{v_1,v_5\} \Longrightarrow$ kein FO[$ \sigma $]-Satz \\ \hline
		\end{tabular} \\\\
		
		
		\item $ \varphi = \exists x \forall y (E(y,x)\vee x=y)$\\
		$ \varphi $ erfüllt $ \mathcal{A} $, da es einen Knoten x gibt, der von allen anderen Knoten y eine eingehende Kante hat. Dies ist genau der unterste Knoten im Graphen. Zu sich selber hat er keine Kante, deswegen gilt die zweite Bedingung 'x=y'. $ \varphi $ erfüllt nicht $ \mathcal{B} $, da es keinen Knoten x in $ \mathcal{B} $ gibt, der von allen anderen Knoten bis auf sich selber eine eingehende Kante hat.\\
		Also gilt: $ \mathcal{A} \models \varphi $ und $ \mathcal{B} \not\models \varphi$
	\end{compactenum}
	\newpage

	\textbf{Aufgabe 04}\\

	\begin{verbatim}
		:- ensure_loaded([kinodb, al]).
		
		% (a)
		george(L) :-
		bagof((K, Z), F^R^(programm(K, F, Z), film(F, R, 'George Clooney')), L).
		
		% (b)
		:- dynamic belegt/3.
		reservieren(P, Z, S) :-
		programm('Babylon', _, Z),
		\+ belegt(_, Z, S),
		assert(belegt(P, Z, S)).
		
		% (c)
		stornieren(Z, S) :-
		retract(belegt(_, Z, S)).
		
		:- dynamic lookup/3.
		
		add_and_square(X, Y, Res) :-
		lookup(X, Y, Res), !.
		
		add_and_square(X, Y, Res) :-
		Res is (X+Y) * (X+Y),
		assert(lookup(X, Y, Res)).
		
		:- dynamic lookup_fak/2.
		
		fak(0, 1).
		fak(N, X) :-
		lookup_fak(N, X), !.
		fak(N, X) :-
		N > 0,
		N2 is N -1,
		fak(N2, X2);
		X is N * X2.
		assert(lookup_fak(N, X)).
		
		% (d)
		negate_lit(L, -L) :- as(L).
		negate_lit(-L, L) :- as(L).
		
		%unit(Klauselmenge, Literal, Klauselmenge2)
		unit([], _, []).
		unit([K|T], L, T2) :-
		member(L, K), !,
		unit(T, L, T2).
		unit([K|T], L, [K2|T2]) :-
		negate_lit(L, LN),
		select(LN, K, K2), !,
		unit(T, L, T2).
		unit([K|T], L, [K|T2]) :-
		unit(T, L, T2).
		
		unit_propagation(K, K2) :-
		member([L], K), !,
		unit(K, L, Kd),
		unit_propagation(Kd, K2).
		unit_propagation(K, K).

	\end{verbatim}
\end{document}
